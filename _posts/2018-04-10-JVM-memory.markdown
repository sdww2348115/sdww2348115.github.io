---layout: posttitle:  "JVM memory"categories: jvmpermalink: /jvm/memory---# JVM内存区域与内存溢出异常## 概述虚拟机JVM的内存管理是Java语言与C/C++语言最典型的差异之一。在虚拟机的帮助下，编写Java程序无需对每一个new操作编写其配对的free操作，一切都由JVM为你搞定，这也是Java语言开发效率比C/C++语言高效的来源之一。JVM内存管理降低了软件开发的门槛，对于刚入门的新手而言，这样的特性无疑是非常友好的。但是，同框架所带来的的问题一样，越方便的东西往往意味着其`自由度`越低，`复杂度`越高。要想编写优美、准确的Java程序，那么理解JVM内存管理的原理，了解它的优点与缺点，知道其特性的边界是非常有必要的。## 数据区域虚拟机在执行Java程序的过程中会将它所管理的内存划分为若干个不同的内存区域：`程序计数器`，`虚拟机栈`，`本地方法栈`，`方法区`，`堆`。在JDK1.8及以后的版本中，方法区被取消，其Class信息、符号引用、常量池、JIT信息等移入到MetaSpace中，静态变量区等被移入到堆中。MetaSpace属于本地内存，且带有内存回收机制。整个Java虚拟机运行时数据区如下所示：![1](asdasd)### 程序计数器程序计数器所占用的空间较小，它可以看做是当前线程所执行字节码的行号指示器，标志当前JVM执行到了字节码的哪一行。所有分支、跳转、循环、异常处理等基础功能都依赖于它。显然的，程序计数器所保存的值仅对Java方法有用，在Native方法中程序计数器始终为空。由于每个线程都有自己的执行逻辑，因此该区域也是每个线程所独有的。该内存空间不存在OOM问题。### Java虚拟机栈Java虚拟机栈与程序计数器相互搭配使用，它也是线程私有。其核心在于栈帧：栈帧保存了一个Java方法在执行过程中需要的信息：局部变量表、操作数栈、动态链接、方法出入口等信息。当Java程序运行进入一个方法时，JVM就会将该方法所对应的栈帧压入虚拟机栈中，当其执行完毕时，对应的栈帧将执行出栈操作。该区域有以下两种关键异常需要注意* 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。其中虚拟机所允许的最大深度并没有明确指定，它与栈帧大小/栈最大空间大小密切相关。* 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。书中采用了一种很巧妙的方式来构建OutOfMemory异常：首先通过设置大容量堆及大容量方法区，将虚拟机栈所能使用的空间压榨得足够小；再通过建立本地线程的方式耗尽其内存资源，达到模拟出OOM的目的。对于这个方法，本人存在一点疑问：虚拟机栈在运行过程中创建的本地方法所使用的空间是否为虚拟机栈中的空间？因为Java程序在运行过程中还会使用JVM之外的本地内存，本地线程是由操作系统所直接管理的，那么本地线程的数据也很有可能是保存在直接内存之中，而非虚拟机栈中。
---
layout: post
title:  "ARTS-2nd"
date:   2019-03-28 21:53:00 +0800
categories: ARTS GC
permalink: /arts/2
---

## Algorithm

见[文章](../../leetcode/304)

## Review

本周阅读的文章是：[Java's new Z Garbage Collector (ZGC) is very exciting](https://www.opsian.com/blog/javas-new-zgc-is-very-exciting/)

文章主要介绍的是JDK 11新引入的GC算法：ZGC以及其诞生的背景、目的、实现时的关键技术以及目前的现状。

JVM中的GC算法自06年的G1后就多年没有再增加新的成员了，原因有两点：G1很全，在停顿时间与吞吐量上的表现都很不错；G1很复杂，JDK团队花了多年时间才把它优化得足够好。但是随着时间的流逝，G1的缺点也开始慢慢显露：G1所支持的heap空间已不能满足当下计算机以及应用的需求了。（G1算法所支持的最大空间：G1中每个Region最大32MB，最多2000个region，因此G1所支持的最大空间为64GB，当下的云主机的内存已经奔着数百GB、甚至是TB级别进行发展）。ZGC诞生的目的就是提供一款支持超大堆的GC算法。

文章对于ZGC的原理介绍较少，但从描述看来，其核心原理与G1有些类似。都是将堆划分为多个块，标记完成后对这些块并发的执行标记-复制清理工作。因此其清理效率很高，而且也能达到软实时水平。在原有基础上，其引入了两种重要的技术：

1. 颜色指针：JVM将指针中的64位划分为两段：低41位用于记录对象地址，剩下的位用于记录额外的信息，譬如在标记清理时对象所处的状态。
2. LoadBarrier：支持某个对象被赋值给某左值之前时做一定的额外操作。（JVM中的面向切面）

毫无疑问，颜色指针可以使得GC线程的并发更加容易，不必再花许多精力用于处理并发问题。LoadBarrier的想象空间就更大了，例如可以将使用不那么频繁的对象进行压缩存储，使用时再通过LoadBarrier进行解压；或者将使用不频繁的对象放在较慢的内存中（比如闪存），使用时再载入到内存中。个人认为，以LoadBarrier使用的频率，如果在其中加入太多逻辑的话可能会得不偿失。而且，当前算法的主流仍是以空间换时间为主，以时间换空间的情况相对较少。

ZGC诞生的时间还不长，当前仍处于实验阶段，官方不建议大家在商业化的xiang，想尝鲜的同学可以在自己的个人项目中试试。

## Tip

## 通过windows自带的netsh命令进行端口数据转发
windows的netsh命令可直接指定端口转发，监听本机某一个端口的数据，将该端口所接收的数据透传至目标机器与目标端口。

## Share

[PausePredictionModel](../../jvm/g1/PausePredictionModel)
---
layout: post
title:  "JVM垃圾回收"
date:   2018-04-15 22:54:01 +0800
categories: jvm
permalink: /jvm/gc
---

## 概述
垃圾回收是一个让Java开发者又爱又恨的特性。一方面，它简化了广大开发者的工作，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new的操作写配对的delete/free操作，不容易出现内存泄漏和内存溢出问题；另一方面，正是因为Java程序员将内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会十分痛苦。

## 内存泄漏与内存溢出
了解与分析JVM的GC过程，最主要的目的就是分析在程序运行过程中可能出现的内存泄漏与内存溢出问题，优化JVM参数，使程序运行更加高效、稳定。

* 内存溢出：即OutOfMemoryError,当程序申请内存空间时，JVM无法分配给程序足够的内存空间导致的错误。本文只分析JVM相关内存区域的OOM错误。（方法区与堆，不包含直接内存）
* 内存泄漏：JVM中无用对象（不再被使用的对象）不能正确被JVM所回收，持续占用内存情况。内存泄漏的问题常常被忽略，因为在程序不出现错误的情况下，开发者们一般不会去关注JVM的内存使用情况；只有在发生严重的JVM内存泄漏，导致JVM出现OOM错误时，开发者们才会去分析JVM的内存泄漏问题。

JVM中的内存泄漏问题与内存溢出问题相伴相生：内存泄漏是根本原因，它会导致JVM的可用内存越来越少，直到最后没有足够内存空间分配，导致抛出OOM错误。OOM错误是表现，开发者们一般只会在JVM发生了OOM错误之后才会去分析JVM的内存使用情况，找到根源处的内存泄漏问题。

## 垃圾回收的对象
所有垃圾回收算法的目的只有一个：清理掉所有不再被使用的对象。如何判断哪些对象是不再被需要的呢？

### 引用计数法
给每个对象添加一个引用计数器，每当有一个地方引用它时，计数器值加一：当引用失效时，计数器就减一；任何时刻只要计数器为0的对象就是不可能再被使用的。该方法的核心逻辑为：对象只能通过引用访问，没有引用的对象自然不能再被访问。 

使用引用计数法的语言有：使用ActionScript的FlashPlayer、python等。其最主要的问题是循环引用问题：对象A持有对象B的引用，对象B持有对象A的引用，除此之外，这两个对象再无任何其他引用。这样的对象实际上已无法再被使用，但由于相互引用的存在，这两个对象无法被垃圾收集器收集回收。

### 可达性分析算法
目前主流语言（Java，C#等）所使用的垃圾回收算法都是通过可达性分析来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为"GC Roots"的对象作为起点，从这些节点开始往下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连接（即GC Roots到这个对象不可达）时，证明此对象是不可用的。

那么，JVM中的GC Roots该如何选取呢？即，在JVM中，如何确定哪些对象是可用的？我们从Java程序的运行谈起：Java程序运行的基本单位是方法，一个Java程序的运行过程就是运行Main方法及其衍生的各种方法的过程。JVM中一个方法的典型运行过程是虚拟机栈帧入栈->运行方法中的逻辑->虚拟机栈帧出栈。自然，在一个方法的运行过程中，其栈帧中的临时对象都是存活的，会被使用的。因此，GC Roots至少应该包含`虚拟机栈帧中的对象`以及`本地方法栈中的对象`。其中本地方法栈中的对象大多直接分配在直接内存中，只有少量保存在JVM中的对象能够标记为GC Roots（比如方法的入参）。除了被线程独占的引用外，还有一些能够被多个线程所共享的引用对象也不应被回收：`常量池`所引用的对象如果被回收，类或方法的描述信息将丢失；`类静态属性`所引用的对象可能会被多个线程所使用，如果被回收也将造成不可预料的后果。

## JVM中的引用
无论是通过引用计数法还是可达性分析算法，判定对线的存活与否都与"引用"相关。JVM中的引用分为4种：

* 强引用：程序代码中普遍存在的引用，类似"Object obj = new Object()"这类。只要强引用存在，垃圾回收器永远不会回收掉被引用的对象。
* 软引用：用来描述有用但非必须的对象。只要JVM还有空间进行分配，就不会回收软引用的对象。一般用于缓存。
* 弱引用：用来描述非必须对象。弱引用不影响对象的回收，即无论是否有该弱引用存在，JVM对于该对象的GC处理逻辑不会有任何不同。常用于容器中，在进行多维定位时使用（例如ThreadLocal），防止内存溢出问题。
* 虚引用：无法通过虚引用获取到对象实例，与虚引用队列相关。其唯一作用便是通过虚引用及队列得到对象被回收的信息。

### 对象被回收的过程
对象被回收需要经历两次标记过程：如果对象在进行可达性分析后发现没有雨GC Roots相连接的引用链，那么它将被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。如果该对象没有覆盖finalize()方法或者finalize()方法已经被虚拟机调用过，则虚拟机将标记该对象没有必要执行finalize()方法。如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放进F-Queue中，由虚拟机的低优先级线程来自动执行finalize()方法。

对象回收的过程需要注意以下几点：

* 对于没有必要执行finalize()方法的对象，JVM仅标记一次就可以将其删除。（使用JavaVirtualVM调用一次System.gc()即可看到JVM所使用的内存急剧减少）
* 对于需要执行finalize()方法的对象，JVM需要进行两次标记。（同上，点击一次执行垃圾回收按钮，JVM开始执行finalize()方法，再按一次可以观察到JVM内存使用量急剧减少）
* 在任何情况下，finalize()方法最多仅会被调用一次。
* 对象必须执行完finalize()方法后才能被回收，所有对象的finalize()都由一个线程执行。所以在使用finalize()方法时，如果出现了死循环，该对象以及后续所有需要执行finalize()方法的对象将都无法被垃圾回收！！

综上，目前的JVM并不推荐使用finalize()方法，所有的资源清理请使用try finally块完成。